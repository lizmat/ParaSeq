=begin pod

=head1 NAME

ParaSeq - Parallel execution of Iterables

=head1 SYNOPSIS

=begin code :lang<raku>

use ParaSeq;

# The 1-millionth prime number: 15485863
say (^Inf).&hyperize.grep(*.is-prime)[999999];
say (^Inf).&hyperize.grep(*.is-prime).skip(999999).head;
say (^Inf).&hyperize(stop-after => 1_000_000).grep(*.is-prime).tail;

# Fetching lines of files, each element containing a List of lines
my @lines = @filenames.&hyperize(1, :!auto).map(*.IO.lines.List);
my %lines = @filenames.&hyperize(1, :!auto).map: { $_ => .IO.lines.List }

=end code

=head1 DESCRIPTION

ParaSeq provides the functional equivalent of
L<C<hyper>|https://docs.raku.org/type/Iterable#method_hyper> and
L<C<race>|https://docs.raku.org/type/Iterable#method_race>, but
re-implemented from scratch with all of the experience from the
initial implementation of C<hyper> and C<race> in 2014, and using
features that have since been added to the Raku Programming Language.

As such it exports two subroutines C<hyperize> and C<racify>, to
make them plug-in compatible with the
L<C<hyperize>|https://raku.land/zef:lizmat/hyperize> distribution.

=head2 STATUS

This module is now considered to be in BETA, as all features
mentioned in the L<IMPROVEMENTS|#IMPROVEMENTS> section have been implemented.

=head1 SUBROUTINES

=head2 hyperize

=begin code :lang<raku>

# The 1-millionth prime number using subroutine syntax: 15485863
say hyperize(^Inf).grep(*.is-prime)[999999];

# Start with 2000 element batches, and use max 10 workers
say (^Inf).&hyperize(2000, 10).grep(*.is-prime)[999999];

# Stop producing results after 1 million values
say (^Inf).&hyperize(stop-after => 1_000_000).grep(*.is-prime).tail;

# Always work with a batch-size of 1
my @lines = @filenames.&hyperize(1, :!auto).map(*.lines.List);

=end code

Change the given C<Iterable> into a C<ParaSeq> object if the following
conditions have been met:

=item degree is more than 1

If the number of simultaneous workers is set to 1, there is no real
parallelizetion possible.  In which case C<hyperize> will simply return
its first argument (the invocant when used with the C<.&hyperize> syntax).

=item source is not exhausted with first batch

If the first batch already exhausts the source iterator, then there is
little point in parallelizing.  A C<Seq> that will reproduce the original
source sequence will then be returned.

=head3 ARGUMENTS

=item source

The first positional argument indicates the C<Iterable> source of values
to be processed.  If the C<.&hyperize> syntax is used, this is the invocant.

=item initial batch size

The second positional argument indicates the initial batch size to be
used.  It defaults to C<16>.  Will also assume the default if an undefined
value is specified.

=item maximum number of simultaneous workers

The third positional argument indicates the maximum number of worker
threads that can be activated to process the values of the source.  It
defaults to the number of available CPUs minus 1.  Will also assume the
defailt if an undefined value is specified.

=item :auto / :!auto

Flag.  Defaults to C<True>.  If specified with a C<False> value, then the
batch size will B<not> be altered from the size (implicitely) specified
with the second positional argument.

=item :stop-after(N)

Integer value.  Defaults to C<Inf>, indicating there is B<no> maximum number
of values that should be delivered.  If specified, should be a positive
integer value: the produced sequence is then B<guaranteed> not to produce
more values than the value given.

=head2 racify

=begin code :lang<raku>

my %lines = @filenames.&racify(1, :!auto).map: { $_ => .IO.lines.List }

=end code

There is no functional difference between C<hyperize> and C<racify> as of
version C<0.0.4>.  So it is only kept to remain compatible with the
C<hyperize> module.

The decision to remove the specific racing capability was made after
it became clear that there was a race condition (no pun intended) in
determining when the iteration was finished.  To fix this deficiency
would require quite a bit of additional logic, that would slow down
execution in both the hypered and racing case.

As the difference in performance between hypering and racing was basically
only one less C<push> / C<shift> per batch, it felt that this would only
be a small price to pay.  On top of that, removing the feature also means
two fewer attribute checks per batch as well, so that could be counted
as an overall win.

=head1 ENDPOINT METHODS

These methods return a single value that could be considered a reduction
of the hypered iteration.  In alphabetical order:

=head2 are

Because the L<C<.are>|https://docs.raku.org/type/Any#method_are> method
is already B<highly> optimized, adding specific hypering would only
slow down execution.  So no specific hypering support has been added.

=head2 categorize

Because the
L<C<.categorize>|https://docs.raku.org/type/List#routine_categorize>
method produces a Hash, putting together the C<Hash> results of each
batch in a correct manner, would be very complicated and potentially
CPU intensive.  Therefore, B<no> specific hypering logic has been
added for this method at this point.

=head2 classify

Because the
L<C<.classify>|https://docs.raku.org/type/List#routine_classify>
method produces a Hash, putting together the C<Hash> results of each
batch in a correct manner, would be very complicated and potentially
CPU intensive.  Therefore, B<no> specific hypering logic has been
added for this method at this point.

=head2 elems

An optimized version of the
L<C<.elems>|https://docs.raku.org/type/List#routine_elems> method
has been implemented.

=head2 end

An optimized version of the
L<C<.end>|https://docs.raku.org/type/List#routine_end> method has
been implemented.

=head2 first

The L<C<.first>|https://docs.raku.org/type/List#routine_first> method
is supported without any specific hypering support added as it
turned out to be impossible to make it faster.

=head2 head

An optimized version of the
L<C<.head>|https://docs.raku.org/type/List#method_head> method
without any arguments (as an endpoint), has been implemented.

=head2 join

An optimized version of the
L<C<.join>|https://docs.raku.org/type/List#routine_join> method
has been implemented.

=head2 max

The L<C<.max>|https://docs.raku.org/type/Any#routine_max> method,
when called B<without> any named arguments, provides the maximum
value without any specific hypering.

=head2 min

The L<C<.min>|https://docs.raku.org/type/Any#routine_min> method,
when called B<without> any named arguments, provides the minimum
value without any specific hypering.

=head2 minmax

An optimized version of the
L<C<.minmax>|https://docs.raku.org/type/Any#routine_minmax> method
has been implemented.

=head2 reduce

An optimized version of the
L<C<.reduce>|https://docs.raku.org/type/List#routine_reduce> method
has been implemented.

B<Caveat>: will only produce the correct results if the order of the
values is B<not> important to determine the final result.

=head2 sum

An optimized version of the
L<C<.sum>|https://docs.raku.org/type/List#routine_sum> method has
been implemented.

=head2 tail

An optimized version of the
L<C<.tail>|https://docs.raku.org/type/List#method_tail> method
without any arguments (as an endpoint), has been implemented.

=head1 INTERFACE METHODS

These methods produce another C<ParaSeq> object that will keep the
parallelization information so that the possibility for parallelization
is used whenever possible.

In alphabetical order:

=head2 antipairs

An optimized version of the
L<C<.antipairs>|https://docs.raku.org/type/List#routine_antipairs>
method has been implemented.

=head2 batch

An optimized version of the
L<C<.batch>|https://docs.raku.org/type/List#method_batch> method
has been implemented.

=head2 collate

The nature of the
L<C<.collate>|https://docs.raku.org/type/Any#method_collate> method
basically makes it impossible to hyper.  Therefore, B<no> specific
hypering logic has been added for this method.

=head2 combinations

The nature of the
L<C<.combinations>|https://docs.raku.org/type/List#routine_combinations>
method basically makes it impossible to hyper.  Therefore, B<no>
specific hypering logic has been added for this method.

=head2 deepmap

An optimized version of the
L<C<.deepmap>|https://docs.raku.org/type/Any#method_deepmap> method
has been implemented.

B<Caveat>: to catch any execution of C<last>, the C<ParaSeq> module
exports its own C<last> subroutine.  This means that any mapper code
will either have to live within the scope in which the C<use ParaSeq>
command is executed, to ensure proper C<last> handling in a hypered
C<.deepmap>.

=head2 duckmap

An optimized version of the
L<C<.duckmap>|https://docs.raku.org/type/Any#method_duckmap> method
has been implemented.

B<Caveat>: to catch any execution of C<last>, the C<ParaSeq> module
exports its own C<last> subroutine.  This means that any mapper code
will either have to live within the scope in which the C<use ParaSeq>
command is executed, to ensure proper C<last> handling in a hypered
C<.duckmap>.

B<Caveat>: due to the way C<duckmap> was implemented before the
C<2024.06> release of Rakudo, the C<LEAVE> phaser would get called
for every value attempted.  This has since been fixed, so that the
C<ENTER> and C<LEAVE> phasers are only called if the C<Callable>
is actually invoked.

=head2 flat

The L<C<.flat>|https://docs.raku.org/type/Any#method_flat> method is
already very simple, and adding hypering overhead would do just that:
add overhead.  Therefore, B<no> specific hypering logic has been
added for this method.

=head2 flatmap

No specific support for the
L<C<.flatmap>|https://docs.raku.org/type/List#method_flatmap> method
has been added, as its core implementation will do the right thing
on C<ParaSeq> objects as well.

=head2 grep

An optimized version of the
L<C<.grep>|https://docs.raku.org/type/List#routine_grep> method has
been implemented.

B<Caveat>: if a C<last> statement is executed, it will ensure that
no further values will be delivered.  However, this may not stop
other threads immediately.  So any other phasers, such as C<ENTER>,
and C<LEAVE> may still get executed, even though the values that
were produced, will not be delivered.

B<Caveat>: to catch any execution of C<last>, the C<ParaSeq> module
exports its own C<last> subroutine.  This means that any matcher code
will either have to live within the scope in which the C<use ParaSeq>
command is executed, to ensure proper C<last> handling in a hypered
C<.grep>.

=head2 head

The L<C<.head>|https://docs.raku.org/type/List#method_head> method is
already very simple, and adding hypering overhead would do just that:
add overhead.  Therefore, B<no> specific hypering logic has been
added for this method.

=head2 invert

The nature of the
L<C<.invert>|https://docs.raku.org/type/List#routine_invert> method
basically makes it impossible to hyper.  Therefore, B<no> specific
hypering logic has been added for this method.

=head2 keys

The L<C<.keys>|https://docs.raku.org/type/List#routine_keys> method
is already very simple, and adding hypering overhead would do just
that: add overhead.  Therefore, B<no> specific hypering logic has
been added for this method.

=head2 kv

An optimized version of the
L<C<.kv>|https://docs.raku.org/type/List#routine_kv> method has been
implemented.

=head2 map

An optimized version of the
L<C<.map>|https://docs.raku.org/type/List#routine_map> method has been
implemented.

B<Caveat>: due to a bug in Rakudo until 2024.06 release, any C<FIRST>
phaser will be run at the start of each batch.  This can be worked
around by using the
L<B<$>, the nameless state variable|https://docs.raku.org/language/variables#The_$_variable>:

=begin code :lang<raku>

@am.&hyperize.map({ FIRST say "first" unless $++; 42 });

=end code

B<Caveat>: if a C<last> statement is executed, it will ensure that
no further values will be delivered.  However, this may not stop
other threads immediately.  So any other phasers, such as C<ENTER>,
C<LEAVE> and C<NEXT> may still get executed, even though the values
that were produced, will not be delivered.

B<Caveat>: to catch any execution of C<last>, the C<ParaSeq> module
exports its own C<last> subroutine.  This means that any mapper code
will either have to live within the scope in which the C<use ParaSeq>
command is executed, to ensure proper C<last> handling in a hypered
C<.map>.

=head2 max

An optimized version of the
L<C<.max>|https://docs.raku.org/type/Any#routine_max> method with
named arguments, has been implemented.

=head2 maxpairs

An optimized version of the
L<C<.maxpairs>|https://docs.raku.org/type/Any#routine_maxpairs> method
has been implemented.

=head2 min

An optimized version of the
L<C<.min>|https://docs.raku.org/type/Any#routine_min> method with
named arguments, has been implemented.

=head2 minpairs

An optimized version of the
L<C<.minpairs>|https://docs.raku.org/type/Any#routine_minpairs> method
has been implemented.

=head2 nodemap

An optimized version of the
L<C<.nodemap>|https://docs.raku.org/type/Any#method_nodemap> method
has been implemented.

B<Caveat>: to catch any execution of C<last>, the C<ParaSeq> module
exports its own C<last> subroutine.  This means that any mapper code
will either have to live within the scope in which the C<use ParaSeq>
command is executed, to ensure proper C<last> handling in a hypered
C<.nodemap>.

=head2 pairs

An optimized version of the
L<C<.pairs>|https://docs.raku.org/type/List#routine_pairs> method
has been implemented.

=head2 pairup

The nature of the
L<C<pairup>|https://docs.raku.org/type/Any#method_pairup> method
basically makes it impossible to hyper.  Therefore, B<no> specific
hypering logic has been added for this method.

=head2 permutations

The nature of the
L<C<.permutations>|https://docs.raku.org/type/List#routine_permutations>
method basically makes it impossible to hyper.  Therefore, B<no>
specific hypering logic has been added for this method.

=head2 pick

The nature of the
L<C<.pick>|https://docs.raku.org/type/List#routine_pick> method
basically makes it impossible to hyper.  Therefore, B<no> specific
hypering logic has been added for this method.

=head2 produce

The nature of the
L<C<.produce>|https://docs.raku.org/type/Any#routine_produce> method
basically makes it impossible to hyper.  Therefore, B<no> specific
hypering logic has been added for this method.

=head2 repeated

The nature of the
L<C<.repeated>|https://docs.raku.org/type/Any#method_repeated> method
basically makes it impossible to hyper.  Therefore, B<no> specific
hypering logic has been added for this method.

=head2 reverse

The nature of the
L<C<.reverse>|https://docs.raku.org/type/List#routine_reverse> method
basically makes it impossible to hyper.  Therefore, B<no> specific
hypering logic has been added for this method.

=head2 roll

The nature of the
L<C<.roll>|https://docs.raku.org/type/List#routine_roll> method
basically makes it impossible to hyper.  Therefore, B<no> specific
hypering logic has been added for this method.

=head2 rotate

The nature of the
L<C<.rotate>|https://docs.raku.org/type/List#routine_rotate> method
basically makes it impossible to hyper.  Therefore, B<no> specific
hypering logic has been added for this method.

=head2 rotor

An optimized version of the
L<C<.rotor>|https://docs.raku.org/type/List#routine_rotor> method
has been implemented for the single argument non-C<Pair> case.  All
other cases are basically too complicated to hyper, and therefore
have no specific hypering logic.

=head2 skip

The simple cases of C<.skip()> and C<.skip(N)> are handled by
skipping that amount on the result iterator and returning the
invocant.

The case of C<.skip(*)> is handled by stopping any production of
values and returning an empty C<Seq>.

The nature of the other types of arguments on the
L<C<.skip>|https://docs.raku.org/type/Seq#method_skip> method
basically makes it impossible to hyper.  Therefore, B<no> specific
hypering logic has been added for these cases.

=head2 slice

The nature of the
L<C<.slice>|https://docs.raku.org/type/Seq#multi_method_slice>
method basically makes it impossible to hyper.  Therefore, B<no>
specific hypering logic has been added for this method.

=head2 snip

The nature of the
L<C<.snip>|https://docs.raku.org/type/Any#routine_snip> method
basically makes it impossible to hyper.  Therefore, B<no> specific
hypering logic has been added for this method.

=head2 snitch

Since it doesn't make much sense for the
L<C<.snitch>|https://docs.raku.org/type/Any#routine_snitch> method
to be called on the C<ParaSeq> object as a whole, calling the
C<.snitch> method instead activates snitcher logic on the
C<ParaSeq> object itself.  If set, the snitcher code will be called
for each input buffer before being scheduled (in a threadsafe
manner).  The snitcher code will receive this buffer as a C<List>.

=head2 sort

The nature of the
L<C<.sort>|https://docs.raku.org/type/List#routine_sort> method
basically makes it impossible to hyper.  Therefore, B<no> specific
hypering logic has been added for this method.

=head2 squish

An optimized version of the
L<C<.squish>|https://docs.raku.org/type/Any#method_squish> method
has been implemented if either a C<:as> named argument has been
specified, or a C<:with> named argument with something other than
the C<===> operator has been specified.  The default case of the
C<.squish> method is already highly optimized so it doesn't make
any sense to add any hypering logic for that case.

=head2 tail

The nature of the
L<C<.tail>|https://docs.raku.org/type/List#method_tail> method
basically makes it impossible to hyper.  Therefore, B<no> specific
hypering logic has been added for this method.

=head2 toggle

The nature of the
L<C<.toggle>|https://docs.raku.org/type/Any#method_toggle> method
basically makes it impossible to hyper.  Therefore, B<no> specific
hypering logic has been added for this method.

=head2 unique

An optimized version of the
L<C<.unique>|https://docs.raku.org/type/Any#method_unique> method
has been implemented.

B<Caveat>: using the C<:with> option with an operator that checks for
B<inequality>, may produce erroneous results.

=head2 values

The L<C<.values>|https://docs.raku.org/type/List#routine_values> is
basically a no-op, so it returns the invocant for simplicity.

=head1 COERCERS

The following coercers have been optimized as much as possible with
the use of C<&hyperize>.  Note that these methods are optimized for
speed, rather than memory usage.  Should you want to optimize for
memory usage, then put in a `.Seq` coercer first.  Or remove
C<.&hyperize> completely.  So:

=begin code :lang<raku>

my $speed  = (^1_000_000).&hyperize.Set;      # optimized for speed
my $memory = (^1_000_000).&hyperize.Seq.Set;  # optimized for memory
my $none   = (^1_000_000).Seq.Set;            # no parallelization

=end code

In alphabetical order:

=head2 Array

The L<C<Array>|https://docs.raku.org/type/Array> coercer has been
implemented: it removes all hypering information from its invocant.

=head2 Bag

Putting together the L<C<Bag>|https://docs.raku.org/type/Bag> of each
batch in a correct manner, would be complicated and potentially CPU
intensive.  Therefore, B<no> specific hypering logic has been added
for this coercer at this point.

=head2 BagHash

Putting together the L<C<BagHash>|https://docs.raku.org/type/BagHash>
of each batch in a correct manner, would be complicated and
potentially CPU intensive.  Therefore, B<no> specific hypering logic
has been added for this coercer at this point.

=head2 Bool

An optimized version of the L<C<Bool>|https://docs.raku.org/type/Bool>
coercer has been implemented.

=head2 eager

The L<C<.eager>|https://docs.raku.org/type/List#routine_eager> method
is functionally the same as the C<.List>, and has been implemented as
such.

=head2 Hash

Putting together the L<C<Hash>|https://docs.raku.org/type/Hash> of
each batch in a correct manner, would be complicated and potentially
CPU intensive.  Therefore, B<no> specific hypering logic has been
added for this coercer at this point.

=head2 Int

An optimized version of the L<C<Int>|https://docs.raku.org/type/Int>
coercer has been implemented.

=head2 IterationBuffer

The L<C<IterationBuffer>|https://docs.raku.org/type/IterationBuffer>
coercer collects the result of the invocant in an C<IterationBuffer>
and returns that.

=head2 list

The L<C<list>|https://docs.raku.org/routine/list> coercer is
implemented: it creates a C<List> object with the object's iterator
as its "todo" (so no elements are reified until they are actually
demanded).  And thus removes all hypering information.

=head2 List

The L<C<List>|https://docs.raku.org/type/List> coercer has been
implemented: it creates a fully reified C<List> and thus removes all
hypering information.

=head2 Map

Putting together the L<C<Map>|https://docs.raku.org/type/Map> of each
batch in a correct manner, would be complicated and potentially CPU
intensive.  Therefore, B<no> specific hypering logic has been added
for this coercer at this point.

=head2 Mix

Putting together the L<C<Mix>|https://docs.raku.org/type/Mix> of
each batch in a correct manner, would be complicated and potentially
CPU intensive.  Therefore, B<no> specific hypering logic has been
added for this coercer at this point.

=head2 MixHash

Putting together the L<C<MixHash>|https://docs.raku.org/type/MixHash>
of each batch in a correct manner, would be complicated and potentially
CPU intensive.  Therefore, B<no> specific hypering logic has been added
for this coercer at this point.

=head2 Numeric

An optimized version of the
L<C<Int>|https://docs.raku.org/type/Numeric> coercer has been
implemented.

=head2 Seq

The L<C<Seq>|https://docs.raku.org/type/Seq> coercer has been
implemented: it removes all hypering information from its invocant.

=head2 serial

The L<C<.serial>|https://docs.raku.org/type/HyperSeq#method_serial>
method is functionally the same as the C<.Seq>, and has been
implemented as such.

=head2 Set

Putting together the L<C<Set>|https://docs.raku.org/type/Set> of each
batch in a correct manner, would be complicated and potentially CPU
intensive.  Therefore, B<no> specific hypering logic has been added
for this coercer at this point.

=head2 SetHash

Putting together the L<C<SetHash>|https://docs.raku.org/type/SetHash>
of each batch in a correct manner, would be complicated and
potentially CPU intensive.  Therefore, B<no> specific hypering logic
has been added for this coercer at this point.

=head2 Slip

The L<C<Slip>|https://docs.raku.org/type/Slip> coercer has been
implemented: it removes all hypering information from its invocant.

=head2 Str

An optimized version of the L<C<Str>|https://docs.raku.org/type/Str>
coercer has been implemented.

=head1 PUBLIC CLASSES

=head2 ParaSeq

The class of which an instance is returned by C<hyperize> and C<racify>
if the requirements for parallelizing have been met.

Can be used in any situation where a C<Seq> could also be used.  The
following additional methods can also be called for introspection and
debugginng.  In alphabetical order:

=head3 auto

Bool.  Returns whether batch sizes will be automatically optimized to
provide the best throughput.

Can also be called as a mutator if a C<Bool> value is specified.  In
that case, returns the invocant for easier chaining.

=head3 batch-sizes

Range.  The smallest and largest batch size as a C<Range>.

=head3 default-batch

Int.  The default initial batch size: currently C<16>.

=head3 default-degree

Int.  The default maximum number of worker threads to be used.  Currently
set to the number of available CPUs minus one.

=head3 hyper

Change hypering settings on invocant and returns invocant.  Takes the
same arguments as C<&hyperize>.

=head3 is-lazy

Bool.  Returns whether the C<ParaSeq> iterator should be considered lazy
or not.  It will be considered lazy if the source iterator is lazy and
B<no> value has been specified with C<:stop-after>.

=head3 processed

Int.  The number of items processed, as obtained from the C<stats>.

=head3 produced

Int.  The number of items produced, as obtained from the C<stats>.

=head3 stats

A C<List> of C<ParaStats> objects that were produced, in the order that
they were produced.  Note that due to the asynchronous nature of stats
production and processing, this may be incomplete at any given time.

=head3 stop-after

Int or False.  Returns C<False> if there is B<no limit> on the number of
values that can be delivered.  Otherwise returns the maximum number of
values that will be delivered.

Can also be called as a mutator if an C<Int> value is specified (or
C<False> to inhibit any resul constraint).  When used as a mutator,
Returns the invocant for easier chaining.

=head3 stopped

Bool.  C<True> if the processing of this C<ParaSeq> has been halted.
Otherwise C<False>

=head3 threads

Returns a C<List> of the IDs of the CPU threads that have been used to
produce the result.

=head2 ParaStats

The C<ParaStats> class is created for each batch that has been processed.
It provides the following methods (in alphabetical order):

=head3 nsecs

Int.  The number of nano-seconds that it took to process all values in
the associated batch.

=head3 ordinal

Int.  The ordinal number of the associated batch (starting at 0).

=head3 processed

Int.  The number of values processed in the associated batch (aka the
batch size of that batch).

=head3 produced

Int.  The number of values that were produced in the associated batch.
This can be C<0>, or a higher value than C<processed> when C<.map> was
called with a C<Callable> that produced C<Slip> values.

=head3 threadid

Int.  The numerical ID of low-level thread that processed the associated
batch (aka its C<$*THREAD.id>).

=head1 IMPROVEMENTS

=head2 Automatic batch size adaptation

One of the main issues with the current implemementation of C<.hyper>
and C<.race> in the Rakudo core is that the batch size is fixed.  Worse,
there is no way to dynamically adapt the batch size depending on the
load.

Batch sizes that are too big, have a tendency to not use all of
the CPUs (because they have a tendency to eat all of the source items
too soon, thus removing the chance to start up more threads).

Batch sizes that are too small, have a tendency to have their resource
usage drowned out by the overhead of batching and dispatching to
threads.

This implementation automatically adapts batch sizes from the originally
(implicitely) specified batch size for better throughput and resource
usage.  If this feature is not desired, the C<:!auto> argument can be
used to switch automatic batch size adjustment off.

=head2 Unnecessary parallelization

If the C<degree> specified is B<1>, then there is no point in batching
or parallelization.  In that case, this implementation will take itself
completely out of the flow.

Alternately, if the initial batch size is large enough to exhaust the
source, it is clearly too large.  Which is interpreted as not making
any sense at parallelization either.  So it won't.

Note that the default initial batch size is B<16>, rather than B<64>
in the current implementation of C<.hyper> and C<.race>, making the
chance smaller that parallelization is abandoned too soon.

=head2 Infectiousness

The C<.serial> method or C<.Seq> coercer can be typically be used to
"unhyper" a hypered sequence.  However many other interface methods do
the same in the current implementation of C<.hyper> and C<.race>,
thereby giving the impression that the flow is still parallelized.
When in fact they aren't anymore.

Also, hyperized sequences in the current implementation are considered
to be non-lazy, even if the source B<is> lazy.

This implementation aims to make all interface methods pass on the
hypered nature and laziness of the sequence.

=head2 Loop control statements

Some loop control statements may affect the final result.  Specifically
the C<last> statement does.  In the current implementation of C<.hyper>
and C<.race>, this will only affect the batch in which it occurs.

This implementation aims to make C<last> stop any processing of current
and not create anymore batches.

=head2 Support more interface methods

Currently only the C<.map> and C<.grep> methods are supported by the
current implementation of C<.hyper> and C<.race> (and not even completely).
Complete support for C<.map> and C<.grep> are provided, and other methods
(such as C<.first>) will also be supported.

=head2 Use of phasers

When an interface method takes a C<Callable>, then that C<Callable>
can contain phasers that may need to be called (or not called) depending
on the situation.  The current implementation of C<.hyper> and C<.race>
do not allow phasers at all.

This implementation aims to support phasers in a sensible manner:

=head3 ENTER

Called before each iteration.

=head3 FIRST

Called on the first iteration in the first batch.

=head3 NEXT

Called at the end of each iteration.

=head3 LAST

Called on the last iteration in the last batch.  Note that this can be
short-circuited with a C<last> control statement.

=head3 LEAVE

Called after each iteration.

=head1 THEORY OF OPERATION

A description of the program logic when you call C<.&hyperize> on an
object.

=head2 Step 1: is degree > 1

If the degree is 1, then there's nothing to parallelize.  The
C<&hyperize> sub will return its first argument.  Since C<.&hyperize>
will most likely mostly be called as a method, the first argument will
be described as the "invocant".

=head2 Step 2: fetch the initial batch

Obtain an iterator from the invocant and read as many items into an
C<IterationBuffer> as the initial batch size indicates.  If this
exhausted the source iterator, then return a C<Seq> on that
C<IterationBuffer>.  This also effectively inhibits any parallelization.

=head2 Step 3: create a ParaSeq

If step 1 and 2 didn't result in a premature return, then a C<ParaSeq>
object is created and returned.  Apart from the initial
C<IterationBuffer> and source iterator, it also contains:

=item the initial batch size
=item the degree (max number of worker threads)
=item the "auto" flag
=item any "stop after" value
=item the $*SCHEDULER value

=head2 Step 4: an interface method is called

Each interface method decides whether they can support an optimized
hypered operation.  If does B<not> support hypered operation, a
special C<BufferIterator> is created.  This iterator takes the buffer
and the source iterator from step 2, that will first deliver the
values from the buffer, and then the values from the source iterator
(until that is exhausted).

The following step then depends on whether the method is an endpoint
(such as C<max>) or a coercer (such as C<Str>).  If it is, then the
C<BufferIterator> will be wrapped in a standard C<Seq> object and
the core equivalent of that method will be called on it and its
result returned.

If it is an other interface method, then a clone of the original
invocant is created with the C<BufferIterator> object as its source
iterator.  And that is then returned.

If the method B<can> be parallized, then we continue.

=head2 Step 5: check granularity of initial batch

Some methods (such as C<map> and C<grep>) B<may> require more than 1
value per iteration (the granularity).  Batches need to have a size with
the correct granularity, otherwise processing a batch may fail at the
last iteration for lack of positional arguments.

So read additional values from the source iterator until the granularity
is correct.

=head2 Step 6: keep producers in check

One of the issues with hypering, is that multiple threads can easily
produce so many values that the deliverer can be overwhelmed in the
worst case.  Or at least, it could be wasteful in resources because it
would produce way more values than would actually need to be delivered.
For example:

=begin code :lang<raku>

say (^Inf).&hyperize.map(*.is-prime)[999999];  # the millionth prime number

=end code

One would not want the parallelization to calculate 1.2 million prime
numbers while only needing 1 million.  Yet, this will happen quite
easily if there is not enough
L<"back pressure"|https://medium.com/@jayphelps/backpressure-explained-the-flow-of-data-through-software-2350b3e77ce7>.

So the thread delivering values, needs to be able to tell the batcher
when it is ok to schedule another batch for processing.  This is
done through a C<ParaQueue> object (a low-level blocking concurrent
queue to which the delivering thread will push whenever it has delivered
the results of a result batch.  Since "back pressure queue" is a bit
of a mouthful, this is being referred to as the "pressure queue".

The deliverer is also responsible for telling the batcher what it
thinks the best size for the next batch is.  See Step 6.

To get things started, a pressure queue is set up with various
batch sizes (one for each degree) so that maximally that many
threads can be started.  By using variable sizes, the delivery
iterator can more quickly decide what the optimum size is for the
given workload because the different batch sizes produce different
average time needed per processed value.  Which is used to calculate
the optimum batch size.

=head2 Step 7: set up the result queue

The result queue is where all of the worker threads post the result
of processing their batch.  The result queue is a C<ParaQueue> of
C<ParaQueue>s.  Whenever the batcher is told that it may queue up
the next batch, the batcher also pushes a new C<ParaQueue> object to
the result queue B<and> passes that C<ParaQueue> object to the worker
thread.  So that when the worker thread is done processing, it can
push its result to B<that> C<ParaQueue>.

The C<ParaQueue> that is pushed to the result queue by the batcher
ensures that the order in which batches of work are handed out, will
also be the order in which the results will be delivered.  The fact
that the result of processing is pushed to this C<ParaQueue> itself,
makes the deliverer block until the worker thread has pushed its
result (even if other threads may have been ready earlier).

=head2 Step 8: set up the waiting queue

To communicate back performance statistics from a worker thread
finishing their work, another C<ParaQueue> is created.  Its sole
purpose is to collect all C<ParaStats> objects that each worker
thread has completed B<as soon as they are done>.  It basically
also represents the number of result batches that are waiting
to be delivered: hence the name "waiting queue".

This queue is inspected by the delivery thread whenever it has
completed delivery of a batch.  It's possible that this queue is
empty.  It can also contain the statistics of more than one worker
thread.

=head2 Step 9: start the batcher thread

The batcher thread keeps running until the source iterator is exhausted.
When it is exhausted, it pushes an C<IterationEnd> to the result queue,
indicating that no more batches will be coming.  It's the only time
a non-C<ParaQueue> object is pushed to the result queue.

The batcher is basically a loop that blocks on the messages from the
deliverer.  Whenever a message is received (with the proposed batch
size, calculated from any available performance statistics), it
adjusts for correct granularity (as the deliverer is unaware of any
granularity restrictions).  The batcher then fetches that many values
from the source iterator and schedules another job for a worker
thread with the values obtained (if any).

=head2 Step 10: start delivering

At this point a C<ParaIterator> object is created and installed as
the (result) C<.iterator> of the invocant.  The paralellizing logic in
the hypered variant of the method is started, which then in turn
starts feeding the C<ParaIterator>.

It is then up to the code that iterators over the (result) iterator
to consume the values delivered.  If no values are being delivered,
production of values will halt after all inital "degree" batches
have been produced.

When the deliverer is done with a result batch, it removes all
available statistics information and adds these to the C<stats>
of the C<ParaSeq> object.  It also uses this information to calculate
an optimum batch size for any other batches to be processed (unless
this is inhibited by the C<:!auto> named argument to C<.&hyperize>).

The algorithm for batch size calculation is pretty simple at the
moment.  To allow for optimum responsiveness of the program, as well
as any other processes running on the computer, a time slice of
500_000 nanoseconds has been chosen.

If a batch took almost exactly that amount of time to produce values,
then the size of that batch is assumed to be the optimum size.  If
the batch took longer, then the batch size should be reduced.  If
the batch took less than that to complete, then the batch size should
be increased.

=head2 Decision tree

=begin code
  source
   \- hyperize
       |- invocant (degree == 1)
       |- Seq      (source exhausted with initial batch)
       |- ParaSeq
           \- method call
               |- endpoint
               |- coercer
               |- hypering
=end code

=head2 Hypering control flow

=begin code
    /---------------------------------------------------------\
    |                |                                        |
    |               ⬇                                         |
    |         --------------                 ------------     |
    |         | statistics |         /-----⮕ | producer | ⮕ -|
    |         --------------        /        ------------     |
    ⬇               ⬇             /                          |
-----------    ------------    -----------   ------------     |
| results | ⮕ | deliverer | ⮕ | batcher | ⮕ | producer | ⮕ -|
-----------    ------------    -----------   ------------     |
                    |              \                          |
                    |               \        ------------     |
                    |                \-----⮕ | producer | ⮕ -/
                    ⬇                        ------------
                 values
          consumed by program
=end code

=head1 AUTHOR

Elizabeth Mattijsen <liz@raku.rocks>

Source can be located at: https://github.com/lizmat/ParaSeq .
Comments and Pull Requests are welcome.

If you like this module, or what I’m doing more generally, committing to a
L<small sponsorship|https://github.com/sponsors/lizmat/>  would mean a great
deal to me!

=head1 COPYRIGHT AND LICENSE

Copyright 2024 Elizabeth Mattijsen

This library is free software; you can redistribute it and/or modify it under
the Artistic License 2.0.

=end pod

# vim: expandtab shiftwidth=4
